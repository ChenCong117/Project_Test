C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE USBPD_POLICY
OBJECT MODULE PLACED IN .\objs\usbpd_policy.obj
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE src\modules\usb_pd\usbpd\usbpd_policy.c OPTIMIZE(8,SIZE) BROWSE INCDIR(./sr
                    -c/include;./src/drivers;./src/lib;./src/modules;./src/events;./src) DEBUG OBJECTEXTEND PRINT(.\objs\usbpd_policy.lst) TA
                    -BS(2) OBJECT(.\objs\usbpd_policy.obj)

line level    source

   1          
   2          #include "usbpd_policy.h"
   3          #include "usbpd_protocol.h"
   4          #include "usb_pd.h"
   5          #include "sw_delay/sw_delay.h"
   6          #include "power/power.h"
   7          
   8          #if (FMOD_USB_PD_OPEN == YES)
   9          
  10          // Qualcomm VID:
  11          #define QUALCOMM_VID          0x05C6
  12          
  13          // PDP Rating Predefinitions: Index = 0 ~ 8 to select target PDP RATING...
  14          #define PDP_RATING_SEL      0
  15          // when max voltage = 12V:
  16          #define PDO_12V_SEL       3
  17          #define PDO_12V_NUM       4
  18          static uint32 code PDO_12V_VAL[PDO_12V_SEL][PDO_12V_NUM] = 
  19          {
  20            // 1. 18W: 5V@3A, 9V@2A, 12V@1.5A, 9V_Prog@2A
  21            {0x0801912C, 0x0802D0C8, 0x0803C096, 0xC8DC2128}, 
  22            // 2. 24W: 5V@3A, 9V@2.5A, 12V@2A, 9V_Prog@2.5A
  23            {0x0801912C, 0x0802D0FA, 0x0803C0C8, 0xC8DC2132},
  24            // 3. 30W: 5V@3A, 9V@3A, 12V@2A, 9V_Prog@3A
  25            {0x0801912C, 0x0802D12C, 0x0803C0C8, 0xC8DC213C}  
  26          };
  27          // when max voltage = 20V:
  28          #define PDO_20V_SEL       6
  29          #define PDO_20V_NUM       6
  30          static uint32 code PDO_20V_VAL[PDO_20V_SEL][PDO_20V_NUM] =  
  31          {
  32            // 1. 27W: 5V@3A, 9V@3A, 12V@2.5A, 15V@1.8A, 20V@1.35A, 9V_Prog@3A
  33            {0x0801912C, 0x0802D12C, 0x0803C0FA, 0x0804B0B4, 0x08064087, 0xC8DC213C},
  34            // 2. 30W: 5V@3A, 9V@2.5A, 12V@2A, 15V@1.5A, 20V@1.2A, 9V_Prog@2.5A
  35            {0x0801912C, 0x0802D0FA, 0x0803C0C8, 0x0804B096, 0x08064078, 0xC8DC2132},
  36            // 3. 36W: 5V@3A, 9V@3A, 12V@2.5A, 15V@2A, 20V@1.5A, 15V_Prog@2A 
  37            {0x0801912C, 0x0802D12C, 0x0803C0FA, 0x0804B0C8, 0x08064096, 0xC9402128},
  38            // 4. 40W: 5V@3A, 9V@3A, 12V@3A, 15V@2.4A, 20V@1.8A, 15V_Prog@2.4A 
  39            {0x0801912C, 0x0802D12C, 0x0803C12C, 0x0804B0F0, 0x080640B4, 0xC9402130},
  40            // 5. 45W: 5V@3A, 9V@3A, 12V@3A, 15V@3A, 20V@2.25A, 20V_Prog@2.25A
  41            {0x0801912C, 0x0802D12C, 0x0803C12C, 0x0804B12C, 0x080640E1, 0xC990212D},
  42            // 6. 60W: 5V@3A, 9V@3A, 12V@3A, 15V@3A, 20V@3A, 20V_Prog@3A
  43            {0x0801912C, 0x0802D12C, 0x0803C12C, 0x0804B12C, 0x0806412C, 0xC990213C}
  44          };
  45          // flag that if support 5A power capability...
  46          static uint8 xdata need_support_5A;  
  47          // pdo number:
  48          static uint8 xdata cur_pdo_num; 
  49          
  50          // PE timers...
  51          // timer index-0:
  52          #define TIMER_NO_RESPONSE       (1 << 0)
  53          #define TIMER_HARDRST_COMPLETE      (1 << 1)
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 2   

  54          #define TIMER_CRC_RECEIVE       (1 << 2)
  55          #define TIMER_PS_TRANSITION       (1 << 3)
  56          #define TIMER_SENDER_RESPONSE     (1 << 4)
  57          #define TIMER_SINK_REQUEST        (1 << 5)
  58          #define TIMER_SINK_WAIT_CAP       (1 << 6)
  59          #define TIMER_SOURCE_CAPABILITY     (1 << 7)
  60          // timer index-1:
  61          #define TIMER_PS_HARD_RESET       (1 << 0)
  62          #define TIMER_VCONN_ON          (1 << 1)
  63          #define TIMER_VCONN_OFF         (1 << 2)
  64          #define TIMER_BIST_CONT_MODE      (1 << 3)
  65          #define TIMER_VDM_RESPONSE        (1 << 4)
  66          #define TIMER_DISCOVER_IDENTITY     (1 << 5)
  67          #define TIMER_SINK_TX         (1 << 6)
  68          #define TIMER_CHUNK_NOT_SUPPORT     (1 << 7)
  69          // timer index-2: 
  70          #define TIMER_CHUNK_SENDER_REQ      (1 << 0)
  71          #define TIMER_CHUNK_SENDER_RESP     (1 << 1)
  72          #define TIMER_SOURCE_PPS_COMM     (1 << 2)
  73          // timer index-3:             
  74          #define TIMER_MS_GENERAL0       (1 << 0)
  75          #define TIMER_MS_GENERAL1       (1 << 1)
  76          #define TIMER_MS_GENERAL2       (1 << 2)
  77          #define TIMER_US_GENERAL0       (1 << 3)
  78          #define TIMER_US_GENERAL1       (1 << 4)
  79          #define TIMER_US_GENERAL2       (1 << 5)
  80          
  81          // timer control:
  82          #define PE_TIMER_ENABLE(idx, bits)    do{regmap0D(0x10 + (idx)) =  (bits);}while(0)
  83          #define PE_TIMER_DISABLE(idx, bits)   do{regmap0D(0x10 + (idx)) = ~(bits);}while(0)
  84          #define PE_TIMER_START(idx, bits)   do{regmap0D(0x14 + (idx)) = (bits); _nop_(); regmap0D(0x14 + (idx)) = 0
             -;}while(0)
  85          #define PE_TIMER_STOP(idx, bits)    do{regmap0D(0x18 + (idx)) = (bits); _nop_(); regmap0D(0x18 + (idx)) = 0;
             -}while(0)
  86          
  87          // message process assist routine:
  88          static void _process_ctrl_message(void);
  89          static void _process_data_message(void); 
  90          static void _process_data_vdm_message(void);
  91          static void _process_structured_vdm_message(void);
  92          static void _process_unstructured_vdm_message(void);  
  93          static void _do_physical_bist(void); 
  94          static bool _send_ctrl_message(uint8 msg_type);
  95          static void _send_hardreset_message(void);  
  96          static bool _send_softreset_message(void);
  97          static bool _send_general_message(void); 
  98          static void _process_extd_message(void); // PD3.0
  99          static bool _parse_extd_message(void);
 100          static bool _send_chunk_req_message(void); 
 101          static bool _send_chunk_resp_message(void);
 102          static bool _send_extend_message(void);
 103          
 104          // state transition...
 105          #define PE_STATE_INVALID          0x60
 106          static uint8 new_port_state; 
 107          // source port state machine: 
 108          #define PE_SRC_HARD_RESET_RECEIVED      200
 109          #define PE_SRC_TRANSITION_TO_DEFAULT    201 
 110          #define PE_SRC_HARD_RESET         202
 111          #define PE_SRC_STARTUP            203
 112          #define PE_SRC_DISCOVERY          204
 113          #define PE_SRC_SEND_CAPABILITIES      205
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 3   

 114          #define PE_SRC_NEGOTIATE_CAPABILITY     206
 115          #define PE_SRC_TRANSITION_SUPPLY      207
 116          #define PE_SRC_READY            208
 117          #define PE_SRC_CAPABILITY_RESPONSE      209
 118          #define PE_SRC_WAIT_NEW_CAPABILITIES    210
 119          #define PE_SRC_GIVE_SOURCE_CAP        211
 120          #define PE_SRC_GET_SINK_CAP         212
 121          static void _pe_src_port_states(uint8 state); 
 122          
 123          // source port routines:
 124          static uint8 xdata snk_req_evaluate_result; // 0: cannot met - 1: can met - other: can met later
 125          static void _src_build_source_capabilities(void); 
 126          static void _src_evaluate_sink_request(void);   
 127          static uint8 xdata src_caps_counter;
 128          // we response data swap...
 129          static bool _dfp2ufp_response_data_swap(uint8 step);
 130          // discover cable id:
 131          static bool _do_cable_discover_identify(void);
 132          
 133          // PD3.0 new messages:
 134          // prepare message routines...
 135          static void _build_source_caps_extend_message(void); 
 136          static void _build_status_message(void); 
 137          static void _build_pps_status_message(void);
 138          // evaluate message routines...
 139          static bool _src_evaluate_sink_alert(void); 
 140          static void _src_evaluate_sink_status(void); 
 141          static void _src_evaluate_sink_caps_extend(void); 
 142          
 143          // extend message index: 
 144          static uint16 xdata cur_ext_rxmsg_index; 
 145          static uint16 xdata cur_ext_txmsg_index; 
 146          
 147          // varialbles:
 148          static uint32 data data_object_t; 
 149          // bist counter...
 150          static uint8 xdata physical_bist_counter;  
 151          // power role... 
 152          bit current_power_role; 
 153          // data role... 
 154          bit current_data_role; 
 155          // vconn role... 
 156          bit current_vconn_role; 
 157          // current version...
 158          uint8 xdata current_pd_version;
 159          // contract status... 
 160          static bit current_contract_status; // 0: not constructed - 1: constructed 
 161          // port state: 
 162          #define PS_STATUS_NONE      10
 163          static uint8 xdata current_port_state   _at_  (GENMEM_REG_BASE + 0x1C); 
 164          //[7]: connect status-> 1=connected, 0=disconnected
 165          //[6:4]: Reserved
 166          //[3:0]: cc detect status -> 1: cc0=cc, 2:cc1=cc, other=no detected
 167          uint8 xdata current_connect_status      _at_  (GENMEM_REG_BASE + 0x1D); 
 168          //_at_  (GENMEM_REG_BASE + 0x001E); // used in usbpd_protocol.c...
 169          //_at_  (GENMEM_REG_BASE + 0x001F); // used in usbpd_protocol.c...
 170          
 171          // trace:
 172          static uint8 xdata snk_timeout_bits     _at_  (GENMEM_REG_BASE + 0x0A);
 173          static uint8 xdata src_timeout_bits     _at_  (GENMEM_REG_BASE + 0x0B);
 174          
 175          // power information:
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 4   

 176          static struct pd_message xdata g_our_capabilities; // our capability...
 177          static uint16 xdata src_negotiated_voltage; // in mV unit...
 178          static uint16 xdata src_negotiated_current; // in mA unit...
 179          static uint16 xdata current_real_voltage; // in mV...
 180          static uint16 xdata current_real_current; // in mA...
 181          static bit current_is_pps_request; 
 182          // power operation: 
 183          static void _build_our_capabilities(uint8 pdp_sel);
 184          static void _switch_out_voltage(uint16 target_voltage); // called after  _switch_out_current()!!!
 185          static void _switch_out_current(uint16 target_current); // called before _switch_out_voltage()!!!
 186          static uint8 extract_apdo_voltage(uint8 max_100mv); 
 187          
 188          // control vbus: 
 189          #define VBUS_CTRL_ENABLE(n)   do{if(n)regmap10(0x0C)|=(1<<1);else regmap10(0x0C)&=~(1<<1);}while(0)
 190          // charge control: 
 191          #define CHARGE_ENABLE(n)    do{if(n)regmap10(0x0C)|=(1<<0);else regmap10(0x0C)&=~(1<<0);}while(0)
 192          
 193          //////////////////////////////////////////// external routines ///////////////////////////////////////////
             -/////
 194          
 195          // init routine:
 196          void usbpd_policy_init(void)
 197          {
 198   1        // enable all timers:
 199   1        PE_TIMER_ENABLE(0, 0xFF); 
 200   1        PE_TIMER_ENABLE(1, 0xFF);
 201   1        PE_TIMER_ENABLE(2, 0xFF);
 202   1        PE_TIMER_ENABLE(3, 0xFF); 
 203   1      
 204   1        // hardware init:
 205   1        VBUS_CTRL_ENABLE(1); // FW can control VBUS...
 206   1      
 207   1        // reset:
 208   1        usbpd_policy_reset();
 209   1         
 210   1        // variables:
 211   1        current_port_state = PE_STATE_INVALID; 
 212   1        snk_timeout_bits = 0;
 213   1        src_timeout_bits = 0; 
 214   1      
 215   1        // important status:
 216   1        current_power_role = PORT_POWER_ROLE_SOURCE; 
 217   1        current_data_role = PORT_DATA_ROLE_DFP; 
 218   1        current_vconn_role = 1; 
 219   1        current_pd_version = SPEC_REV30; 
 220   1        current_connect_status = 0x00;
 221   1      
 222   1        // init our capabilities:
 223   1        _build_our_capabilities(PDP_RATING_SEL); 
 224   1      
 225   1        // set start up state: (just for debug) 
 226   1        //_pe_snk_port_states(PE_SNK_TRANSITION_TO_DEFAULT); // assume we're sink...
 227   1        //_pe_src_port_states(PE_SRC_TRANSITION_TO_DEFAULT); // assume we're source...
 228   1      }
 229          
 230          // reset routine:
 231          void usbpd_policy_reset(void)
 232          {
 233   1        // stop timer:
 234   1        PE_TIMER_STOP(0, 0xFF);
 235   1        PE_TIMER_STOP(1, 0xFF);
 236   1        PE_TIMER_STOP(2, 0xFF);
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 5   

 237   1        PE_TIMER_STOP(3, 0xFF); 
 238   1      
 239   1        // variables: 
 240   1        physical_bist_counter = 0; 
 241   1        // extend message index:
 242   1        cur_ext_rxmsg_index = 0;
 243   1        cur_ext_txmsg_index = 0;
 244   1        // current version:
 245   1        current_pd_version = SPEC_REV30; 
 246   1        // new state:
 247   1        new_port_state = PE_STATE_INVALID; 
 248   1        // support 5A:
 249   1        need_support_5A = 0; 
 250   1        
 251   1        // power information: 
 252   1        src_negotiated_voltage = 0;
 253   1        src_negotiated_current = 0;
 254   1        current_is_pps_request = 0; 
 255   1      }
 256          
 257          // event process:
 258          void usbpd_event_process(uint16 event_bits)
 259          {
 260   1        // hardreset received:
 261   1        if(event_bits & USBPD_EVT_HARDRST_RECEIVED)
 262   1        {
 263   2          // move to PE_SRC_Hard_Reset_Received state:
 264   2          _pe_src_port_states(PE_SRC_HARD_RESET_RECEIVED); 
 265   2        }
 266   1        // source capabilities changed (when in source role)...
 267   1        if(event_bits & USBPD_EVT_SRC_CAPS_CHANGED)
 268   1        {
 269   2          // move to PE_SRC_Send_Capabilities state:
 270   2          _pe_src_port_states(PE_SRC_SEND_CAPABILITIES); 
 271   2        }
 272   1        // sink request changed (when in sink role)...
 273   1        if(event_bits & USBPD_EVT_SNK_REQ_CHANGED)
 274   1        {
 275   2      
 276   2        }
 277   1        // we're source, sink attached:
 278   1        if(event_bits & USBPD_EVT_PORT_CONNECTED)
 279   1        {
 280   2          // in state machine:
 281   2          _pe_src_port_states(PE_SRC_TRANSITION_TO_DEFAULT);
 282   2        }
 283   1        // we're source, sink detached:
 284   1        if(event_bits & USBPD_EVT_PORT_DISCONNECTED)
 285   1        {
 286   2          // reset protocol:
 287   2          usbpd_protocol_reset();
 288   2          // reset policy: 
 289   2          usbpd_policy_reset();
 290   2        }
 291   1        if(event_bits & USBPD_EVT_STATE_TRANSITION)
 292   1        {
 293   2          // source state:
 294   2          _pe_src_port_states(new_port_state);
 295   2          // reset:
 296   2          new_port_state = PE_STATE_INVALID;
 297   2        }
 298   1      }
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 6   

 299          
 300          // entry for process message: which pointed by pd_rxmsg_ptr... 
 301          void usbpd_message_process(void)
 302          {
 303   1        // some misc process:
 304   1        PE_TIMER_STOP(0, TIMER_SINK_REQUEST);   // when we're source...
 305   1      
 306   1        // we should be in connect status:
 307   1        if((current_connect_status & 0x80) == 0)
 308   1        {
 309   2          // if not connected, do nothing...
 310   2          return; 
 311   2        }
 312   1      
 313   1        // check if in physical bist:
 314   1        if(physical_bist_counter)
 315   1        {
 316   2          // we're in bist mode, need hard reset:
 317   2          return; 
 318   2        }
 319   1        
 320   1        // 2. if general message, first check message type:  
 321   1        if(pd_rxmsg_ptr->_msg_head.bits._num_data_objects == 0) 
 322   1        {
 323   2          // process control message:
 324   2          _process_ctrl_message(); 
 325   2        }
 326   1        else    
 327   1        {
 328   2          // here we should check if it's extended message...
 329   2          if(pd_rxmsg_ptr->_msg_head.bits._extended)
 330   2          {      
 331   3            // if the extend message is completed:
 332   3            if(_parse_extd_message())
 333   3            {
 334   4              // process extended message - PD3.0:
 335   4              _process_extd_message(); 
 336   4            } 
 337   3          }
 338   2          else
 339   2          {
 340   3            // process data message:
 341   3            _process_data_message(); 
 342   3          } 
 343   2        }
 344   1      }
 345          
 346          // process pe timers:
 347          void usbpd_timer_process(uint8 index, uint8 bits)
 348          {
 349   1        if(index == 0)
 350   1        {
 351   2          if(bits & TIMER_SENDER_RESPONSE)
 352   2          {       
 353   3            // trace:
 354   3            src_timeout_bits = bits;
 355   3            // enter PE_SRC_HardReset:
 356   3            _pe_src_port_states(PE_SRC_HARD_RESET); 
 357   3          } 
 358   2          if(bits & TIMER_SOURCE_CAPABILITY)
 359   2          {
 360   3            // goto PE_SRC_Send_Capabilities state: 
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 7   

 361   3            _pe_src_port_states(PE_SRC_SEND_CAPABILITIES); 
 362   3          } 
 363   2        }
 364   1        else if(index == 1)
 365   1        {
 366   2          if(bits & TIMER_PS_HARD_RESET)
 367   2          {
 368   3            // reset voltage to vSafe0v:
 369   3            CHARGE_ENABLE(0);  
 370   3            // tSrcRecover = 0.66 - 1s - 2017.10.26
 371   3            {
 372   4              uint8 i;
 373   4              for(i=0; i<8; ++i) 
 374   4              {
 375   5                sw_delay_100ms(); 
 376   5              }
 377   4            }
 378   3            // move to default state:
 379   3            _pe_src_port_states(PE_SRC_TRANSITION_TO_DEFAULT); 
 380   3          }
 381   2          if(bits & TIMER_VCONN_ON)
 382   2          {
 383   3            // send hard reset:
 384   3            src_timeout_bits = bits; 
 385   3            _pe_src_port_states(PE_SRC_HARD_RESET);
 386   3          }
 387   2        }
 388   1        else if(index == 2)
 389   1        {
 390   2          if(bits & TIMER_SOURCE_PPS_COMM)
 391   2          {
 392   3            // send hard reset:
 393   3            src_timeout_bits = bits; 
 394   3            _pe_src_port_states(PE_SRC_HARD_RESET); 
 395   3          }
 396   2        } 
 397   1      }
 398          
 399          //////////////////////////// internal message process routines  ///////////////////////////////////
 400          
 401          // control mesage parse:
 402          void _process_ctrl_message(void)
 403          {
 404   1        switch(pd_rxmsg_ptr->_msg_head.bits._message_type)
 405   1        {
 406   2          // GoodCRC: will not happened...
 407   2          case CTRL_MSG_GOODCRC:  
 408   2          break;
 409   2      
 410   2          //////////////////////////////////////// GotoMin //////////////////////////////////////////
 411   2          case CTRL_MSG_GOTOMIN:  
 412   2          break;
 413   2      
 414   2            //////////////////////////////////////// Accept /////////////////////////////////////////// 
 415   2          case CTRL_MSG_ACCEPT:
 416   2          break;
 417   2      
 418   2          //////////////////////////////////////// Reject /////////////////////////////////////////// 
 419   2          case CTRL_MSG_REJECT:
 420   2          break;
 421   2      
 422   2          ///////////////////////////////////////// Ping ////////////////////////////////////////////
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 8   

 423   2            case CTRL_MSG_PING: 
 424   2          // nothing to do...    
 425   2          break;
 426   2          
 427   2          //////////////////////////////////////// PS_RDY ///////////////////////////////////////////
 428   2          case CTRL_MSG_PS_RDY:
 429   2          break;
 430   2      
 431   2          ///////////////////////////////////// Get_Source_Cap //////////////////////////////////////
 432   2          case CTRL_MSG_GET_SOURCE_CAP:  
 433   2          // we're source, send our capabilities...
 434   2          _pe_src_port_states(PE_SRC_GIVE_SOURCE_CAP);
 435   2          break;    
 436   2      
 437   2          ////////////////////////////////////// Get_Sink_Cap ///////////////////////////////////////
 438   2          case CTRL_MSG_GET_SINK_CAP:
 439   2          // we're source, just reject it...
 440   2          _send_ctrl_message((current_pd_version >= SPEC_REV30) ? CTRL_MSG_NOT_SUPPORT : CTRL_MSG_REJECT); 
 441   2          break;
 442   2      
 443   2          //////////////////////////////////////// DR_Swap ////////////////////////////////////////// 
 444   2          case CTRL_MSG_DR_SWAP:
 445   2          // for support qc4, we have to...
 446   2          if(current_data_role == PORT_DATA_ROLE_DFP)
 447   2          {
 448   3            // we do data role swap only when we're dfp...
 449   3            if(_dfp2ufp_response_data_swap(1))
 450   3            {
 451   4              // move to 2nd step directly...
 452   4              _dfp2ufp_response_data_swap(2);  
 453   4            }
 454   3          }
 455   2          else 
 456   2          {  
 457   3            // we're ufp and didnt' want to become DFP...
 458   3            _send_ctrl_message((current_pd_version >= SPEC_REV30) ? CTRL_MSG_NOT_SUPPORT : CTRL_MSG_REJECT);
 459   3          } 
 460   2          // not support...
 461   2          //_send_ctrl_message((current_pd_version >= SPEC_REV30) ? CTRL_MSG_NOT_SUPPORT : CTRL_MSG_REJECT);
 462   2          break;  
 463   2      
 464   2          //////////////////////////////////////// PR_Swap //////////////////////////////////////////
 465   2          case CTRL_MSG_PR_SWAP:
 466   2          // not support... 
 467   2          _send_ctrl_message((current_pd_version >= SPEC_REV30) ? CTRL_MSG_NOT_SUPPORT : CTRL_MSG_REJECT); 
 468   2          break;
 469   2      
 470   2          /////////////////////////////////////// VCONN_Swap ////////////////////////////////////////  
 471   2          case CTRL_MSG_VCONN_SWAP:
 472   2          // we don't support VCONN swap whatever we're sink or source...   
 473   2          _send_ctrl_message((current_pd_version >= SPEC_REV30) ? CTRL_MSG_NOT_SUPPORT : CTRL_MSG_REJECT);  
 474   2          break;
 475   2      
 476   2          ///////////////////////////////////////// Wait ////////////////////////////////////////////  
 477   2          case CTRL_MSG_WAIT:        
 478   2          break;
 479   2      
 480   2          ///////////////////////////////////// Soft_Reset ////////////////////////////////////////// 
 481   2          case CTRL_MSG_SOFT_RESET:
 482   2          if(!_send_ctrl_message(CTRL_MSG_ACCEPT))
 483   2          {
 484   3            // goto Hard reset state:
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 9   

 485   3            _pe_src_port_states(PE_SRC_HARD_RESET); 
 486   3          }
 487   2          else
 488   2          {
 489   3            // goto PE_SRC_Send_Capabilities state: 
 490   3            _pe_src_port_states(PE_SRC_STARTUP); 
 491   3          }
 492   2          break;  
 493   2      
 494   2          //////////////////////////////////// PD3.0 Added Message //////////////////////////////////
 495   2           
 496   2          ////////////////////////////////////// Not_Supported ////////////////////////////////////// 
 497   2          case CTRL_MSG_NOT_SUPPORT:
 498   2          // do nothing...
 499   2          break; 
 500   2      
 501   2          ////////////////////////////////// Get_Source_Cap_Extended //////////////////////////////// 
 502   2          case CTRL_MSG_GET_SOURCE_CAP_EXT:
 503   2          // build our source caps extend and send...
 504   2          _build_source_caps_extend_message();
 505   2          _send_extend_message(); 
 506   2          //_send_ctrl_message(CTRL_MSG_NOT_SUPPORT); 
 507   2          break; 
 508   2      
 509   2          ////////////////////////////////////// Get_Status ///////////////////////////////////////// 
 510   2          case CTRL_MSG_GET_STATUS:
 511   2          // build message and send...
 512   2          _build_status_message(); 
 513   2          _send_extend_message(); 
 514   2          //_send_ctrl_message(CTRL_MSG_NOT_SUPPORT); 
 515   2          break; 
 516   2      
 517   2          /////////////////////////////////////// FR_Swap /////////////////////////////////////////// 
 518   2          case CTRL_MSG_FR_SWAP:
 519   2          // not support in default..
 520   2          _send_ctrl_message((current_pd_version >= SPEC_REV30) ? CTRL_MSG_NOT_SUPPORT : CTRL_MSG_REJECT); 
 521   2          break; 
 522   2      
 523   2          //////////////////////////////////// Get_PPS_Status /////////////////////////////////////// 
 524   2          case CTRL_MSG_GET_PPS_STATUS:
 525   2          // build pps status message:
 526   2          _build_pps_status_message(); 
 527   2          _send_extend_message(); 
 528   2          //_send_ctrl_message(CTRL_MSG_NOT_SUPPORT); 
 529   2          break; 
 530   2      
 531   2          /////////////////////////////////// Get_Country_Codes ///////////////////////////////////// 
 532   2          case CTRL_MSG_GET_COUNTRY_CODES:
 533   2          // not support in default: 
 534   2          _send_ctrl_message(CTRL_MSG_NOT_SUPPORT); 
 535   2          break; 
 536   2      
 537   2          ////////////////////////////////// Get_Sink_Cap_Extended ////////////////////////////////// 
 538   2          case CTRL_MSG_GET_SINK_CAP_EXT:
 539   2          // not support:
 540   2          _send_ctrl_message(CTRL_MSG_NOT_SUPPORT); 
 541   2          break;
 542   2      
 543   2          /////////////////////////////////// Unrecognized Message //////////////////////////////////
 544   2          default: 
 545   2          // do nothing if we dind't know it...
 546   2          if(current_pd_version == SPEC_REV30) 
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 10  

 547   2          {
 548   3            // for pd3.0 only...
 549   3            _send_ctrl_message(CTRL_MSG_NOT_SUPPORT);
 550   3          }
 551   2          break; 
 552   2        }     
 553   1      }
 554          
 555          // data message process:
 556          void _process_data_message(void)
 557          {
 558   1        switch(pd_rxmsg_ptr->_msg_head.bits._message_type)
 559   1        {
 560   2          ////////////////////////////////// Source_Capabilities ////////////////////////////////////
 561   2          case DATA_MSG_SOURCE_CAPS: 
 562   2          break;
 563   2      
 564   2          /////////////////////////////////////// Request /////////////////////////////////////////// 
 565   2          case DATA_MSG_REQUEST:
 566   2          // negotiate requeset:
 567   2          _pe_src_port_states(PE_SRC_NEGOTIATE_CAPABILITY);
 568   2          // check engotiate result:
 569   2          if(snk_req_evaluate_result)
 570   2          {
 571   3            // can be met:
 572   3            _pe_src_port_states(PE_SRC_TRANSITION_SUPPLY); 
 573   3          }  
 574   2          else
 575   2          {
 576   3            // cannot be met or can be met later...
 577   3            _pe_src_port_states(PE_SRC_CAPABILITY_RESPONSE); 
 578   3            // check if we're in explicit contract already:
 579   3            if(!current_contract_status)
 580   3            {
 581   4              // goto PE_SRC_Wait_New_Capabilities state...
 582   4              _pe_src_port_states(PE_SRC_WAIT_NEW_CAPABILITIES);
 583   4            }
 584   3            else
 585   3            {
 586   4              // we cann't meet, but current 
 587   4              _pe_src_port_states(PE_SRC_READY);  
 588   4            }
 589   3          }                    
 590   2          break;
 591   2      
 592   2          ///////////////////////////////////////// BIST //////////////////////////////////////////// 
 593   2          case DATA_MSG_BIST: 
 594   2          {
 595   3            // only for cts test...
 596   3            _do_physical_bist();
 597   3          }     
 598   2          break;
 599   2      
 600   2          /////////////////////////////////// Sink_Capabilities /////////////////////////////////////
 601   2          case DATA_MSG_SINK_CAPS:
 602   2          // we didn't send Get_Sink_Capabilities, so we will not receive this message...  
 603   2          break;
 604   2      
 605   2          ///////////////////////////////////// Battery Status //////////////////////////////////////
 606   2          case DATA_MSG_BATTERY_STATUS:
 607   2          // do nothing as it won't happen...
 608   2          break; 
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 11  

 609   2      
 610   2          ///////////////////////////////////////// Alert ///////////////////////////////////////////
 611   2          case DATA_MSG_ALERT:
 612   2          // when recevie alert, we have to send get status to see what's going on...
 613   2          if(!_src_evaluate_sink_alert()); 
 614   2          {
 615   3            // process non-battery change only...
 616   3            _send_ctrl_message(CTRL_MSG_GET_STATUS); 
 617   3          }
 618   2          break; 
 619   2      
 620   2          //////////////////////////////////// Get_Country_Info /////////////////////////////////////
 621   2          case DATA_MSG_GET_COUNTRY_INFO:
 622   2          // not support in default...
 623   2          _send_ctrl_message(CTRL_MSG_NOT_SUPPORT); 
 624   2          break; 
 625   2      
 626   2          ///////////////////////////////////// Vendor_Defined //////////////////////////////////////
 627   2          case DATA_MSG_VENDOR_DEFINED:  
 628   2            {
 629   3            // vdm message, including alt-mode...
 630   3            _process_data_vdm_message();
 631   3          }
 632   2          break;
 633   2      
 634   2          /////////////////////////////////// Unrecognized Message //////////////////////////////////
 635   2          default: 
 636   2          // we didn't support it:
 637   2          _send_ctrl_message(CTRL_MSG_NOT_SUPPORT); 
 638   2          break;
 639   2        }       
 640   1      }  
 641          
 642          void _process_extd_message(void)
 643          {
 644   1        switch(pd_rxmsg_ptr->_msg_head.bits._message_type)
 645   1        {
 646   2          ///////////////////////////// Source_Capabilities_Extended ////////////////////////////////
 647   2          case EXTD_MSG_SOURCE_CAPS_EXT: 
 648   2          // won't receive this message, haha...
 649   2          break;
 650   2      
 651   2          /////////////////////////////////////// Status ////////////////////////////////////////////
 652   2          case EXTD_MSG_STATUS:
 653   2          // check parter's status after sending get_status message...
 654   2          break; 
 655   2      
 656   2          ////////////////////////////////// Get_Battery_Cap ////////////////////////////////////////
 657   2          case EXTD_MSG_GET_BATTERY_CAP:     
 658   2          // not support in default...
 659   2          _send_ctrl_message(CTRL_MSG_NOT_SUPPORT); 
 660   2          break;
 661   2          
 662   2          ///////////////////////////////// Get_Battery_Status //////////////////////////////////////
 663   2          case EXTD_MSG_GET_BATTERY_STATUS:
 664   2          // not suppport in default...
 665   2          _send_ctrl_message(CTRL_MSG_NOT_SUPPORT); 
 666   2          break;
 667   2      
 668   2          //////////////////////////////// Battery_Capabilities /////////////////////////////////////
 669   2          case EXTD_MSG_BATTERY_CAPS: 
 670   2          // won't receive...
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 12  

 671   2          break;
 672   2      
 673   2          //////////////////////////////// Get_Manufacture_Info /////////////////////////////////////
 674   2          case EXTD_MSG_GET_MANU_INFO:
 675   2          // not support for a while...
 676   2          _send_ctrl_message(CTRL_MSG_NOT_SUPPORT); 
 677   2          break;
 678   2      
 679   2          ////////////////////////////////// Manufacturer_Info //////////////////////////////////////
 680   2          case EXTD_MSG_MANU_INFO:
 681   2          // won't receive...
 682   2          break;
 683   2      
 684   2          ////////////////////////////////// Security_Request ///////////////////////////////////////
 685   2          case EXTD_MSG_SECURITY_REQ:
 686   2          // not support it totoally...
 687   2          _send_ctrl_message(CTRL_MSG_NOT_SUPPORT); 
 688   2          break;
 689   2      
 690   2          ////////////////////////////////// Security_Response //////////////////////////////////////
 691   2          case EXTD_MSG_SECURITY_RESP:
 692   2          // won't receive...
 693   2          break;
 694   2      
 695   2          /////////////////////////////// Firmware_Update_Request ///////////////////////////////////
 696   2          case EXTD_MSG_FW_UPDATE_REQ:
 697   2          // not support...
 698   2          _send_ctrl_message(CTRL_MSG_NOT_SUPPORT); 
 699   2          break;
 700   2      
 701   2          ////////////////////////////// Firmware_Update_Response ///////////////////////////////////
 702   2          case EXTD_MSG_FW_UPDATE_RESP:
 703   2          // won't receive...
 704   2          break;
 705   2      
 706   2          ///////////////////////////////////// PPS_Status //////////////////////////////////////////
 707   2          case EXTD_MSG_PPS_STATUS:
 708   2          // won't receive...
 709   2          break; 
 710   2      
 711   2          //////////////////////////////////// Country_Info /////////////////////////////////////////
 712   2          case EXTD_MSG_COUNTRY_INFO:
 713   2          // won't receive...
 714   2          break;
 715   2      
 716   2          //////////////////////////////////// Country_Codes ////////////////////////////////////////
 717   2          case EXTD_MSG_COUNTRY_CODES:   
 718   2          // won't receive...
 719   2          break; 
 720   2      
 721   2          ///////////////////////////// Sink_Capabilities_Extended //////////////////////////////////
 722   2          case EXTD_MSG_SINK_CAPS_EXT: 
 723   2          // won't receive...
 724   2          break;
 725   2      
 726   2          /////////////////////////////////// Unrecognized Message //////////////////////////////////
 727   2          default: 
 728   2          // we didn't support it:
 729   2          _send_ctrl_message(CTRL_MSG_NOT_SUPPORT); 
 730   2          break;
 731   2        } 
 732   1      }
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 13  

 733          
 734          // structured vendor_defined message process:
 735          void _process_data_vdm_message(void)
 736          {
 737   1        uint8 num_data_obj;
 738   1        uint8 response_type = TYPE_RESP_ACK;
 739   1        struct pd_vdm_message xdata * rx_vdm_msg = (struct pd_vdm_message xdata *)pd_rxmsg_ptr; 
 740   1        struct pd_vdm_message xdata * tx_vdm_msg = (struct pd_vdm_message xdata *)pd_txmsg_ptr;
 741   1      
 742   1        // pre-constructure message:
 743   1        // 1. message header:
 744   1        tx_vdm_msg->_msg_head.bits._extended = 0;
 745   1        tx_vdm_msg->_msg_head.bits._message_type = DATA_MSG_VENDOR_DEFINED;
 746   1        num_data_obj = 1; 
 747   1        // 2. vdm header: 
 748   1        tx_vdm_msg->_vdm_head._value = rx_vdm_msg->_vdm_head._value;
 749   1      
 750   1        // here, we have to process both structured and unstructured(qc4) message!!!
 751   1        if(rx_vdm_msg->_vdm_head.bits._vdm_type)
 752   1        {
 753   2          // structured vmd message:
 754   2          #if (SUPPORT_CABLE_DISCOVERY == 1)
                  switch(rx_vdm_msg->_vdm_head.bits._command)
                  {
                  // we only process discover identity... 
                  case VDM_CMD_DISCOVER_IDENTITY:
                    data_object_t = V32_ENDIAN_SWAP(rx_vdm_msg->_data_objects[3]); // get product types vdo
                    // B10-9: voltage: we don't care as voltage selected by sink...
                    // B6-5: current:
                    if(((data_object_t >> 5) & 3) == 0x02) // 0x02 -> 5A 
                    {
                      need_support_5A = 1; // update status..
                    }
                      break;
                  default:
                    return;
                  }
                  // final check response type:
                  tx_vdm_msg->_vdm_head.bits._command_type = response_type; 
                  #endif 
 773   2        }
 774   1        /*
 775   1        else
 776   1        {
 777   1          // unstructured vmd message:
 778   1          uint8 val; 
 779   1          if(rx_vdm_msg->_vdm_head.bits_qc._command0 != 0x03)
 780   1            return; 
 781   1          // cmd0 must be 0x03...
 782   1          switch(rx_vdm_msg->_vdm_head.bits_qc._command1)
 783   1          {
 784   1          case VDM_CMD_QC_INQUIRE_CHG_TEMP: 
 785   1            val = power_read_temperature(0); // internal temperature
 786   1            data_object_t = (val > 20) ? (val - 20) : 0; 
 787   1            break;
 788   1            case VDM_CMD_QC_INQUIRE_CON_TEMP:
 789   1            val = power_read_temperature(1); // external temperature
 790   1            data_object_t = (val > 20) ? (val - 20) : 0;
 791   1            break;
 792   1          case VDM_CMD_QC_INQUIRE_CON_VOL:
 793   1            data_object_t = power_read_voltage(); // voltage
 794   1            break; 
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 14  

 795   1          case VDM_CMD_QC_INQUIRE_CHG_TYPE:
 796   1            data_object_t = 0x00000004; // 0x02: QC2, 0x03: QC3, 0x04: QC4
 797   1            break; 
 798   1          case VDM_CMD_QC_INQUIRE_CHG_VER:
 799   1            data_object_t = 0x00000030; // Rev3.0
 800   1            break; 
 801   1          default:
 802   1            return;       
 803   1          }
 804   1          // vdm header construction...
 805   1          tx_vdm_msg->_vdm_head.bits_qc._command0 = VDM_RESP_QC_ACK;
 806   1          tx_vdm_msg->_data_objects[0] = V32_ENDIAN_SWAP(data_object_t); 
 807   1          num_data_obj += 1; 
 808   1        }
 809   1        */
 810   1      
 811   1        // construct data object number finally...important!!!
 812   1        tx_vdm_msg->_msg_head.bits._num_data_objects = num_data_obj; 
 813   1      
 814   1        // 3. vdm data objects...is ready!!!
 815   1        if(current_data_role == PORT_DATA_ROLE_UFP)
 816   1        {
 817   2          // OK! send it out only when we're UFP...
 818   2          if(!_send_general_message())
 819   2            return;
 820   2        }
 821   1      }
 822          
 823          ///////////////////////////////////////////////////////////////////////////////////////////////////
 824          
 825          void _send_hardreset_message(void)
 826          {
 827   1        // send hardreset message:
 828   1        usbpd_send_hardreset(0); 
 829   1        // Start PSHardResetTimer:
 830   1        PE_TIMER_START(1, TIMER_PS_HARD_RESET); 
 831   1      }
 832          
 833          // control message...
 834          bool _send_softreset_message(void)
 835          {
 836   1        pd_txmsg_ptr->_msg_head.bits._message_type = CTRL_MSG_SOFT_RESET;
 837   1        pd_txmsg_ptr->_msg_head.bits._num_data_objects = 0; 
 838   1        pd_txmsg_ptr->_msg_head.bits._port_power_role = current_power_role; 
 839   1        pd_txmsg_ptr->_msg_head.bits._port_data_role = current_data_role;
 840   1        pd_txmsg_ptr->_msg_head.bits._spec_revision = current_pd_version; 
 841   1        pd_txmsg_ptr->_msg_head.bits._extended = 0; 
 842   1        if(!usbpd_message_transmission())
 843   1        {
 844   2          // if softreset failed, send hardreset:
 845   2          _send_hardreset_message(); 
 846   2          // we should reset something...alternate mode at least...
 847   2          usbpd_policy_reset(); 
 848   2          // failed...
 849   2          return false; 
 850   2        }
 851   1        else
 852   1        {
 853   2          // stop all timers:
 854   2          PE_TIMER_STOP(0, 0xFF);
 855   2          PE_TIMER_STOP(1, 0xFF);
 856   2          PE_TIMER_STOP(2, 0xFF); 
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 15  

 857   2          // if sucess, we need wait accept in tRecevierResponse...
 858   2          PE_TIMER_START(0, TIMER_SENDER_RESPONSE);
 859   2          // success???
 860   2          return true; 
 861   2        }   
 862   1      }
 863          
 864          bool _send_general_message(void) 
 865          {
 866   1        // we should update power role and data role here...double confirm!!! - 2017.10.18
 867   1        pd_txmsg_ptr->_msg_head.bits._port_power_role = current_power_role; 
 868   1        pd_txmsg_ptr->_msg_head.bits._port_data_role = current_data_role;
 869   1        pd_txmsg_ptr->_msg_head.bits._spec_revision = current_pd_version; 
 870   1      
 871   1          // message payload is ready actually...
 872   1        if(!usbpd_message_transmission())
 873   1        {
 874   2          // send softreset:
 875   2          _send_softreset_message();
 876   2          // always failed...
 877   2          return false;
 878   2        }
 879   1        return true; 
 880   1      }
 881          
 882          bool _send_ctrl_message(uint8 msg_type)
 883          {
 884   1        pd_txmsg_ptr->_msg_head.bits._message_type = msg_type;
 885   1        pd_txmsg_ptr->_msg_head.bits._num_data_objects = 0;
 886   1        pd_txmsg_ptr->_msg_head.bits._extended = 0; 
 887   1        return _send_general_message();     
 888   1      } 
 889          
 890          #if (SUPPORT_MULTI_CHUNK_MSG == 1)
              bool _send_chunk_req_message(void)
              {
                  struct pd_chk_message xdata * tx_chk_msg = (struct pd_chk_message xdata *)pd_txmsg_ptr; 
                struct pd_chk_message xdata * rx_chk_msg = (struct pd_chk_message xdata *)pd_rxmsg_ptr;
                // message header: 
                tx_chk_msg->_msg_head.bits._extended = rx_chk_msg->_msg_head.bits._extended; 
                tx_chk_msg->_msg_head.bits._message_type = rx_chk_msg->_msg_head.bits._message_type; 
                tx_chk_msg->_msg_head.bits._num_data_objects = 1; 
                // extend header:
                tx_chk_msg->_ext_head.bits._chunked = 1; 
                tx_chk_msg->_ext_head.bits._chunk_num = rx_chk_msg->_ext_head.bits._chunk_num + 1; 
                tx_chk_msg->_ext_head.bits._req_chunk  = 1;
                tx_chk_msg->_ext_head.bits._data_size0 = 0;
                tx_chk_msg->_ext_head.bits._data_size1 = 0; 
                // data objects:
                memset((void*)tx_chk_msg->_data_bytes, 0, CHK_MSG_MAX); 
                // send message:
                return _send_general_message();
              }
              #endif
 911          
 912          #if (SUPPORT_MULTI_CHUNK_MSG == 1)
              bool _send_chunk_resp_message(void)
              {
                uint16 len; 
                uint16 total_size;  
                  struct pd_chk_message xdata * tx_chk_msg = (struct pd_chk_message xdata *)pd_txmsg_ptr; 
                struct pd_chk_message xdata * rx_chk_msg = (struct pd_chk_message xdata *)pd_rxmsg_ptr;
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 16  

              
                // total size:
                total_size = pd_ext_txmsg_ptr->_ext_head.bits._data_size0; 
                total_size = (total_size << 8) + pd_ext_txmsg_ptr->_ext_head.bits._data_size1;
              
                // check left bytes:
                len = total_size - cur_ext_txmsg_index; 
                if(len > CHK_MSG_MAX)
                  len = CHK_MSG_MAX; 
              
                // message header:
                tx_chk_msg->_msg_head.bits._extended = rx_chk_msg->_msg_head.bits._extended; 
                tx_chk_msg->_msg_head.bits._message_type = rx_chk_msg->_msg_head.bits._message_type; 
                tx_chk_msg->_msg_head.bits._num_data_objects = (uint8)((len + 2 + 3) >> 2); 
                // extend header:
                tx_chk_msg->_ext_head.bits._chunked = 1; 
                tx_chk_msg->_ext_head.bits._chunk_num = rx_chk_msg->_ext_head.bits._chunk_num; 
                tx_chk_msg->_ext_head.bits._req_chunk  = 0;
                tx_chk_msg->_ext_head.bits._data_size0 = pd_ext_txmsg_ptr->_ext_head.bits._data_size0;
                tx_chk_msg->_ext_head.bits._data_size1 = pd_ext_txmsg_ptr->_ext_head.bits._data_size1;
                // data:
                memset((void*)tx_chk_msg->_data_bytes, 0, CHK_MSG_MAX); 
                memcpy((void*)tx_chk_msg->_data_bytes, (void*)&pd_ext_txmsg_ptr->_data_bytes[cur_ext_txmsg_index], len); 
                cur_ext_txmsg_index += len; 
                // reset index if all completed!
                if(cur_ext_txmsg_index >= total_size)
                  cur_ext_txmsg_index = 0; 
                // send it:
                return _send_general_message(); 
              }
              #endif
 950          
 951          bool _parse_extd_message(void)
 952          {
 953   1        struct pd_chk_message xdata * rx_chk_msg = (struct pd_chk_message xdata *)pd_rxmsg_ptr;
 954   1      
 955   1        if(rx_chk_msg->_ext_head.bits._chunked == 0)
 956   1        {
 957   2          // we don't support unchunked message whatever how long it is...
 958   2          _send_ctrl_message(CTRL_MSG_NOT_SUPPORT); 
 959   2          return false; 
 960   2        }
 961   1      
 962   1        #if (SUPPORT_MULTI_CHUNK_MSG == 1)
                {
                uint16 len, total_size;  
                // first we check if it's chunk reqest...
                if(rx_chk_msg->_ext_head.bits._req_chunk)
                {
                  // just a request, we repsonse it!
                  _send_chunk_resp_message(); 
                  // not need do anything...
                  return false; 
                }
                // it's normal message, ohh...I mean it's not chunk request... 
                // check total data size:
                total_size = rx_chk_msg->_ext_head.bits._data_size0; 
                total_size = (total_size << 8) + rx_chk_msg->_ext_head.bits._data_size1; 
                if(total_size <= CHK_MSG_MAX)
                {
                  // not need request/response mechanism:
                  memcpy((void*)pd_ext_rxmsg_ptr, (void*)rx_chk_msg, sizeof(struct pd_chk_message)); 
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 17  

                  return true; 
                }
                else
                {   
                  // check if the startup...
                  if(rx_chk_msg->_ext_head.bits._chunk_num == 0)
                  {
                    // record message:
                    memcpy((void*)pd_ext_rxmsg_ptr, (void*)rx_chk_msg, sizeof(struct pd_chk_message));
                    cur_ext_rxmsg_index = CHK_MSG_MAX; 
                    // we have to send chunk_request message here...
                    _send_chunk_req_message(); 
                    // not complete yet...
                    return false; 
                  }
                  else 
                  {
                    // in middle transfer...
                    // 1. check data length of this message:
                    len = rx_chk_msg->_msg_head.bits._num_data_objects * 4 - 2; // 4-bytes boundary...
                    // 2. record data: 
                    memcpy((void*)&pd_ext_rxmsg_ptr->_data_bytes[cur_ext_rxmsg_index], (void*)rx_chk_msg->_data_bytes, len)
             -;
                    cur_ext_rxmsg_index += len; 
                    // 3. check if completed...
                    if(cur_ext_rxmsg_index < total_size)
                    {
                      // still not enough, send chunk request...
                      _send_chunk_req_message(); 
                      // not complete yet...
                      return false;   
                    }
                    else
                    {
                      // reset index if all completed!
                      cur_ext_rxmsg_index = 0; 
                      // ok, it's enough...
                      return true; 
                    }
                  }
                }
                }
                #else // #if (SUPPPORT_MULTI_CHUNK_MSG == 1) 
1023   1        {
1024   2          // not need request/response mechanism, copy directly...
1025   2          memcpy((void*)pd_ext_rxmsg_ptr, (void*)rx_chk_msg, sizeof(struct pd_chk_message)); 
1026   2          return true; 
1027   2        }
1028   1        #endif // #if (SUPPPORT_MULTI_CHUNK_MSG == 1)
1029   1      }
1030          
1031          bool _send_extend_message(void)
1032          {
1033   1        uint16 len; 
1034   1        uint16 total_size; 
1035   1        struct pd_chk_message xdata * tx_chk_msg = (struct pd_chk_message xdata *)pd_txmsg_ptr; 
1036   1        struct pd_chk_message xdata * rx_chk_msg = (struct pd_chk_message xdata *)pd_rxmsg_ptr;
1037   1       
1038   1        // check if it can be transfer in one chunk message:
1039   1        total_size = pd_ext_txmsg_ptr->_ext_head.bits._data_size0; 
1040   1        total_size = (total_size << 8) + pd_ext_txmsg_ptr->_ext_head.bits._data_size1;
1041   1        len = (total_size > CHK_MSG_MAX) ? CHK_MSG_MAX : total_size; 
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 18  

1042   1      
1043   1        // 1. message header:
1044   1        tx_chk_msg->_msg_head.bits._extended = 1; 
1045   1        tx_chk_msg->_msg_head.bits._message_type = pd_ext_txmsg_ptr->_msg_head.bits._message_type; 
1046   1        tx_chk_msg->_msg_head.bits._num_data_objects = (uint8)((len + 2 + 3) >> 2); // 4-bytes boundary...
1047   1        // 2. extend header:
1048   1        tx_chk_msg->_ext_head.bits._chunked = 1;  // double confirm...
1049   1        tx_chk_msg->_ext_head.bits._chunk_num = 0; 
1050   1        tx_chk_msg->_ext_head.bits._req_chunk = 0;
1051   1        tx_chk_msg->_ext_head.bits._data_size0 = pd_ext_txmsg_ptr->_ext_head.bits._data_size0;
1052   1        tx_chk_msg->_ext_head.bits._data_size1 = pd_ext_txmsg_ptr->_ext_head.bits._data_size1;
1053   1        // 3. data objects:
1054   1        memset((void*)tx_chk_msg->_data_bytes, 0, CHK_MSG_MAX); 
1055   1        memcpy((void*)tx_chk_msg->_data_bytes, (void*)pd_ext_txmsg_ptr->_data_bytes, len); 
1056   1        cur_ext_txmsg_index = len; 
1057   1        // ok, send it:
1058   1        return _send_general_message(); 
1059   1      }
1060          
1061          void _do_physical_bist(void)
1062          {
1063   1        uint8 mode = pd_rxmsg_ptr->_data_objects[0] & 0xF0; // bit[31:24] - not do endian swap...
1064   1        switch(mode)
1065   1        {
1066   2        case 0x50: // we only process BIST Carrier Mode 2 
1067   2          // enable bist mode...
1068   2          //regmap2D(0x12) |= 0x80; 
1069   2          // delay 30-60ms
1070   2          sw_delay_10ms();
1071   2          sw_delay_10ms();
1072   2          sw_delay_10ms();
1073   2          sw_delay_10ms();
1074   2          // disable bist mode...
1075   2          //regmap2D(0x12) &= 0x7F;
1076   2          break;
1077   2        }
1078   1        physical_bist_counter += 1;
1079   1        if(physical_bist_counter == 0)
1080   1        {   
1081   2          // keep it not be zero...
1082   2          physical_bist_counter = 1;  
1083   2        }
1084   1      }
1085          
1086          ////////////////////////////////////// source port state machine /////////////////////////////////////////
             -///
1087          
1088          void _pe_src_port_states(uint8 state)
1089          {
1090   1        uint8 old_state = current_port_state; // record previous state...
1091   1      
1092   1        // record current state:
1093   1        current_port_state = state;
1094   1      
1095   1        switch(state)
1096   1        {
1097   2        case PE_SRC_HARD_RESET:
1098   2          {
1099   3          // send hardreset signal:
1100   3          usbpd_send_hardreset(0); 
1101   3          }
1102   2          // no break!!!
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 19  

1103   2        case PE_SRC_HARD_RESET_RECEIVED:
1104   2          {
1105   3          // as no break above: 
1106   3          current_port_state = PE_SRC_HARD_RESET_RECEIVED;
1107   3          // Start PSHardResetTimer:
1108   3          PE_TIMER_START(1, TIMER_PS_HARD_RESET);   
1109   3          }
1110   2          break; 
1111   2        case PE_SRC_TRANSITION_TO_DEFAULT:
1112   2          {
1113   3          // Reset protocol layer, which should in StartUp stage...
1114   3          usbpd_protocol_reset(); 
1115   3          // reset policy layer:
1116   3          usbpd_policy_reset(); 
1117   3        
1118   3          // flag that contract not valid:
1119   3          current_contract_status = 0; 
1120   3        
1121   3          // request device policy manager to request power sink transition to default:
1122   3          // reset local hardware 
1123   3          // if type-C set port data role to UFP and turn off VCONN:
1124   3          // set output to vSafe5v:  
1125   3          _switch_out_current(300); 
1126   3          _switch_out_voltage(100); // default is 5V@3A...
1127   3          // enable output: 
1128   3          CHARGE_ENABLE(1); 
1129   3          }
1130   2          // no break!!! 
1131   2        case PE_SRC_STARTUP: 
1132   2          {
1133   3          // as no break above: 
1134   3          current_port_state = PE_SRC_STARTUP;
1135   3          // Reset CapsCounter:
1136   3          src_caps_counter = 0; 
1137   3          // here, we need discover cable type to see if it support 5A...
1138   3          #if (SUPPORT_CABLE_DISCOVERY == 1)
                  if(_do_cable_discover_identify())
                  {
                    // if respond, start timer to wait message...
                    PE_TIMER_START(0, TIMER_SOURCE_CAPABILITY);
                    break;
                  } 
                  #endif 
1146   3          }
1147   2          // no break!!! 
1148   2        case PE_SRC_SEND_CAPABILITIES: 
1149   2          {
1150   3          // as no break above:
1151   3          current_port_state = PE_SRC_SEND_CAPABILITIES; 
1152   3          // build source capabilities message:
1153   3          _src_build_source_capabilities();
1154   3          // increase capscounter:
1155   3          src_caps_counter += 1; 
1156   3          // send capability:
1157   3          if(usbpd_message_transmission())
1158   3          {
1159   4            // success! - Start SenderResponseTimer:
1160   4            PE_TIMER_START(0, TIMER_SENDER_RESPONSE);
1161   4          }
1162   3          else
1163   3          {
1164   4            // check if need to continue send capabilities: 150ms/time
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 20  

1165   4            usbpd_protocol_reset(); // reset message id...
1166   4            if(src_caps_counter < 50) // 3 times in previous...   30 * 150ms = 4.5s 
1167   4            {
1168   5              // send failed! - Start SourceCapabilityTimer to re-send...
1169   5              PE_TIMER_START(0, TIMER_SOURCE_CAPABILITY); 
1170   5            }
1171   4          }
1172   3          }
1173   2          break; 
1174   2        case PE_SRC_NEGOTIATE_CAPABILITY:
1175   2          {
1176   3          // stop SenderResponseTimer:
1177   3          PE_TIMER_STOP(0, TIMER_SENDER_RESPONSE); 
1178   3          // evaluate the sink request...
1179   3          _src_evaluate_sink_request(); 
1180   3          // pps common timer:
1181   3          if(current_is_pps_request)
1182   3          {
1183   4            PE_TIMER_STOP(2, TIMER_SOURCE_PPS_COMM);
1184   4          } 
1185   3          }
1186   2          break; 
1187   2        case PE_SRC_CAPABILITY_RESPONSE:
1188   2          {
1189   3          // here, we reject the request as we didn't consider power reserve...
1190   3          _send_ctrl_message(CTRL_MSG_REJECT); 
1191   3          }
1192   2          break; 
1193   2        case PE_SRC_WAIT_NEW_CAPABILITIES:
1194   2          {
1195   3          // do nothing...
1196   3          }
1197   2          break; 
1198   2        case PE_SRC_TRANSITION_SUPPLY:
1199   2          {
1200   3          // Initialize and run SourceActivityTimer
1201   3          // If GotoMin send GotoMin Message, else send Accept Message
1202   3          if(!_send_ctrl_message(CTRL_MSG_ACCEPT)) // for Lecroy test, we have to check if success - 2018.10.22
1203   3            break; 
1204   3          // Wait tSrcTransition(25~35ms) and request Device Policy Manager to transition power supply:
1205   3          sw_delay_10ms(); 
1206   3          sw_delay_10ms();
1207   3          sw_delay_10ms();
1208   3          // switch to target power...
1209   3          _switch_out_current(src_negotiated_current); 
1210   3          _switch_out_voltage(src_negotiated_voltage); 
1211   3          // Send PS_RDY message:
1212   3          _send_ctrl_message(CTRL_MSG_PS_RDY); 
1213   3          }
1214   2          // no break!!! 
1215   2        case PE_SRC_READY:
1216   2          {
1217   3          // as no break above: 
1218   3          current_port_state = PE_SRC_READY;
1219   3          // flag that contract created:
1220   3          current_contract_status = 1; 
1221   3          // start source pps common timer for pps: 
1222   3          if(current_is_pps_request)
1223   3          {
1224   4            PE_TIMER_START(2, TIMER_SOURCE_PPS_COMM);   
1225   4          }
1226   3          }
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 21  

1227   2          break; 
1228   2        case PE_SRC_GIVE_SOURCE_CAP:
1229   2          {
1230   3          // build source capabilities message:
1231   3          _src_build_source_capabilities();
1232   3          // send capability: whatever success or failed...
1233   3          _send_general_message();
1234   3          // this is not a valud state:
1235   3          current_port_state = old_state; 
1236   3          }
1237   2          break;
1238   2        }
1239   1      }
1240          
1241          void _src_build_source_capabilities(void)
1242          {
1243   1        // now we didn't do any modification...but we might modify something in future...
1244   1        memcpy((void*)pd_txmsg_ptr, (void*)&g_our_capabilities, sizeof(struct pd_message));
1245   1      }
1246          
1247          // true: can be met - false: can't be met or can be met later...
1248          void _src_evaluate_sink_request(void)
1249          { 
1250   1        uint8 pdo_position, version; 
1251   1        uint16 opr_current; 
1252   1        uint16 opr_voltage; // for pps pdo... 
1253   1        uint16 max_current; // for fix pdo...
1254   1        uint16 cap_current; 
1255   1        uint32 cur_cap_pdo;  
1256   1      
1257   1        // check parter version:
1258   1        version = pd_rxmsg_ptr->_msg_head.bits._spec_revision;
1259   1        if(version < SPEC_REV30)
1260   1        {
1261   2          // if partner is not pd3.0, we go back to what it is...
1262   2          current_pd_version = version;  
1263   2        } 
1264   1      
1265   1        // evaluate power: only one power data object exist...
1266   1        // fix & variable RDO...
1267   1        // bit[30-28]: object position
1268   1        // bit[27]: giveback flag
1269   1        // bit[26]: cabability mismatch
1270   1        // bit[25]: usb communication capable
1271   1        // bit[24]: no usb suspend
1272   1        // bit[23]: unchunked extended message supported
1273   1        // bit[19-10]: operating current in 10mA
1274   1        // bit[09-00]: max operating current in 10mA 
1275   1      
1276   1        // little-endian -> big-endian:
1277   1        data_object_t = V32_ENDIAN_SWAP(pd_rxmsg_ptr->_data_objects[0]);
1278   1      
1279   1        // check position: 
1280   1        pdo_position = (data_object_t >> 28) & 0x07;
1281   1        if(pdo_position == 0 || pdo_position > cur_pdo_num)
1282   1        {
1283   2          // position should be valid...
1284   2          snk_req_evaluate_result = 0; 
1285   2          return;   
1286   2        }
1287   1      
1288   1        // check capability mismatch bit first:
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 22  

1289   1        if((data_object_t >> 26) & 0x01)
1290   1        {
1291   2          // we cannot meet the sink's requirement...
1292   2          snk_req_evaluate_result = 0; 
1293   2          return;   
1294   2        }
1295   1      
1296   1        // we need still check if the voltage and current exceed our capablitity...
1297   1        cur_cap_pdo = V32_ENDIAN_SWAP(g_our_capabilities._data_objects[pdo_position-1]);
1298   1        // check if pps request...
1299   1        switch((cur_cap_pdo >> 30) & 0x03) 
1300   1        {
1301   2        case 0x03: // pps request:
1302   2          current_is_pps_request = 1; 
1303   2          break; 
1304   2        case 0x00: // fix request:
1305   2          current_is_pps_request = 0; 
1306   2          break;
1307   2        default:
1308   2          snk_req_evaluate_result = 0;
1309   2          return;   
1310   2        }
1311   1        
1312   1        if(current_is_pps_request)
1313   1        {
1314   2          // pps request...
1315   2          opr_voltage = (data_object_t >> 9) & 0x7FF;  // bit 19-9 in 20mV 
1316   2          opr_current = (data_object_t >> 0) & 0x07F;  // bit 6-0 in 50mA 
1317   2          // only current capabilty...
1318   2          cap_current = cur_cap_pdo & 0x000000FF; // bit 7-0 in 50mA
1319   2        }
1320   1        else
1321   1        {
1322   2          // fix request...
1323   2            opr_voltage = (cur_cap_pdo >> 10) & 0x3FF; // bit 19-10 in 50mV --- opr_voltage = cap_voltage
1324   2          opr_current = (data_object_t >> 10) & 0x3FF; // bit 19-10 in 10mA
1325   2          max_current = (data_object_t >> 0) & 0x3FF; // bit 9-0 in 10mA
1326   2          // only current capability...
1327   2          cap_current = (cur_cap_pdo & 0x3FF) * 10; // bit 9-0 in 10mA
1328   2        }
1329   1      
1330   1        {
1331   2          // judge if exceed what we have...
1332   2          if(opr_current > cap_current || max_current > cap_current) 
1333   2          {
1334   3            snk_req_evaluate_result = 0;
1335   3            return;
1336   3          }
1337   2        
1338   2          // record negotiated volatage & current:
1339   2          src_negotiated_voltage = opr_voltage; // voltage...
1340   2          src_negotiated_current = opr_current; 
1341   2        }
1342   1      
1343   1        // OK! 
1344   1        snk_req_evaluate_result = 1;    
1345   1      } 
1346          
1347          // response data swap: 
1348          bool _dfp2ufp_response_data_swap(uint8 step)
1349          {
1350   1        switch(step)
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 23  

1351   1        {
1352   2        case 1: 
1353   2          // we receive dr_swap, just accept...
1354   2          if(!_send_ctrl_message(CTRL_MSG_ACCEPT))
1355   2            return false;
1356   2          break; 
1357   2        case 2: 
1358   2          // update and wait for alt-mode operation...
1359   2          current_data_role = PORT_DATA_ROLE_UFP; 
1360   2          break;    
1361   2        }
1362   1        return true; 
1363   1      } 
1364          
1365          #if (SUPPORT_CABLE_DISCOVERY == 1)
              bool _do_cable_discover_identify(void)
              {
                // message header:
                pd_txmsg_ptr->_msg_head.bits._message_type = DATA_MSG_VENDOR_DEFINED;
                pd_txmsg_ptr->_msg_head.bits._num_data_objects = 1;
              
                // vdm_header:
                pd_txmsg_ptr->_data_objects[0] = V32_ENDIAN_SWAP(0xFF008001);
                
                // send it directly without softreset even failed...
                {
                  uint8 i; 
                  for(i=0; i<20; ++i)
                  {
                    // set sop type to SOP'...
                    usbpd_set_msg_type(MSG_TYPE_SOP1P);
                    // send directly, not cause soft reset... 
                    if(usbpd_message_transmission())
                      break; 
                    // delay some time:
                    sw_delay_1ms(); 
                  } 
                  return (i < 20) ? true : false; 
                }
              }
              #endif
1392          
1393          ///////////////////////////////////// assist routines /////////////////////////////////////////////
1394          
1395          /*
1396          void _init_our_capabilities(uint8 pdo_num)
1397          {
1398            uint8 i;
1399            uint16 voltage;
1400            uint16 current; 
1401            // init our source capabilities as maybe we use external power...
1402            // when we connect to charger, which will over-write this with its capabilities...
1403            // header:
1404            g_our_capabilities._msg_head.bits._num_data_objects = pdo_num; 
1405            g_our_capabilities._msg_head.bits._port_power_role = current_power_role;
1406            g_our_capabilities._msg_head.bits._spec_revision = current_pd_version;
1407            g_our_capabilities._msg_head.bits._port_data_role = current_data_role;
1408            g_our_capabilities._msg_head.bits._message_type = DATA_MSG_SOURCE_CAPS;
1409            g_our_capabilities._msg_head.bits._extended = 0;
1410            // data object:
1411            // dual-role power (bit-29) = 0
1412            // usb suspend  (bit-28) = 0
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 24  

1413            // external power (bit-27) = 1
1414            // USB communication capable (bit-26) = 1
1415            // data role swap (bit-25) = 1
1416            // unchunk extend message support (bit-24) = 0
1417            // reserved (bit 23-22) = 0
1418            // peak current (bit 21-20) = 00
1419            // voltage (bit 19-10)
1420            // current (bit 09-00)
1421            // mandatory data object - 5V/2A: 
1422            // calculate voltage/current:
1423            voltage = (PREDEF_VOL[0] / 50); 
1424            current = (PREDEF_CUR[0] / 10); 
1425            data_object_t = 0x08000000 | ((uint32)voltage << 10) | current; 
1426            g_our_capabilities._data_objects[0] = V32_ENDIAN_SWAP(data_object_t);
1427            for(i = 1; i < pdo_num; ++i)
1428            {
1429              // calculate voltage/current:
1430              voltage = (PREDEF_VOL[i] / 50); 
1431              current = (PREDEF_CUR[i] / 10); 
1432                // data object:
1433              data_object_t = 0x00000000 | ((uint32)voltage << 10) | current;
1434              g_our_capabilities._data_objects[i] = V32_ENDIAN_SWAP(data_object_t);
1435            }
1436          }
1437          */ 
1438          
1439          void _build_our_capabilities(uint8 pdp_sel)
1440          {
1441   1        uint8 i;  
1442   1      
1443   1        // ** data object for PDO: 
1444   1        // dual-role power (bit-29) = 0
1445   1        // usb suspend  (bit-28) = 0
1446   1        // external power (bit-27) = 1
1447   1        // USB communication capable (bit-26) = 1
1448   1        // data role swap (bit-25) = 1
1449   1        // unchunk extend message support (bit-24) = 0
1450   1        // reserved (bit 23-22) = 0
1451   1        // peak current (bit 21-20) = 00
1452   1        // voltage (bit 19-10)
1453   1        // current (bit 09-00)
1454   1      
1455   1        // ** data object for APDO:
1456   1        // type (bit 31-30) = 11
1457   1        // power limit (bit 27) = 1
1458   1        // max voltage (bit 24-17)
1459   1        // min voltage (bit 15-8)
1460   1        // max current (bit 7-0)
1461   1      
1462   1        if(pdp_sel < PDO_12V_SEL)
1463   1        {
1464   2          cur_pdo_num = PDO_12V_NUM; 
1465   2          for(i=0; i<PDO_12V_NUM; ++i)
1466   2            g_our_capabilities._data_objects[i] = V32_ENDIAN_SWAP(PDO_12V_VAL[pdp_sel][i]); 
1467   2        }
1468   1        else 
1469   1        {
1470   2          cur_pdo_num = PDO_20V_NUM; 
1471   2          for(i=0; i<PDO_20V_NUM; ++i)
1472   2            g_our_capabilities._data_objects[i] = V32_ENDIAN_SWAP(PDO_20V_VAL[pdp_sel-3][i]);
1473   2        }
1474   1      
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 25  

1475   1        // init our source capabilities as maybe we use external power...
1476   1        // when we connect to charger, which will over-write this with its capabilities...
1477   1        // header:
1478   1        g_our_capabilities._msg_head.bits._num_data_objects = cur_pdo_num; 
1479   1        g_our_capabilities._msg_head.bits._port_power_role = current_power_role;
1480   1        g_our_capabilities._msg_head.bits._spec_revision = current_pd_version;
1481   1        g_our_capabilities._msg_head.bits._port_data_role = current_data_role;
1482   1        g_our_capabilities._msg_head.bits._message_type = DATA_MSG_SOURCE_CAPS;
1483   1        g_our_capabilities._msg_head.bits._extended = 0;
1484   1      } 
1485          
1486          // switch our power to negotiatied power cap...
1487          void _switch_out_voltage(uint16 target_voltage)
1488          {
1489   1        // voltage: unit - 20mV for pps, 50mV for pd
1490   1        power_set_voltage(target_voltage, current_is_pps_request); 
1491   1      }
1492          
1493          void _switch_out_current(uint16 target_current)
1494          {
1495   1        // current: unit - 50mA for pps, 10mA for pd
1496   1        power_set_current(target_current, current_is_pps_request);  
1497   1      }
1498          
1499          //////////////////////////////////////// PD3.0 New Message ////////////////////////////////////////
1500          
1501          bool SNK_IS_SinkTxOK(void)
1502          { 
1503   1        return true; 
1504   1      } 
1505          
1506          void _build_source_caps_extend_message(void)
1507          {
1508   1        // response of get_source_cap_extened message...
1509   1        // message header: 
1510   1        pd_ext_txmsg_ptr->_msg_head.bits._message_type = EXTD_MSG_SOURCE_CAPS_EXT; 
1511   1        // extend header: 
1512   1        pd_ext_txmsg_ptr->_ext_head.bits._data_size0 =  0; 
1513   1        pd_ext_txmsg_ptr->_ext_head.bits._data_size1 = 24; 
1514   1        // data: 24 bytes
1515   1        memset((void*)pd_ext_txmsg_ptr->_data_bytes, 0x00, 24); // reset all values... 
1516   1      }
1517          
1518          // true: battery change - false: other changes...
1519          bool _src_evaluate_sink_alert(void)
1520          {
1521   1        // little-endian -> big-endian:
1522   1        data_object_t = V32_ENDIAN_SWAP(pd_rxmsg_ptr->_data_objects[0]);
1523   1      
1524   1        // Bit-25: Battery Status Change:
1525   1        if((data_object_t >> 25) & 1) 
1526   1        {
1527   2          return true; 
1528   2        }
1529   1        else
1530   1        {
1531   2          return false; 
1532   2        }
1533   1      }
1534          
1535          // when we receive get_status message...
1536          void _build_status_message(void)
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 26  

1537          {
1538   1         
1539   1      }
1540          
1541          // when receive status message...
1542          void _src_evaluate_sink_status(void)
1543          {
1544   1        
1545   1      }
1546          
1547          void _src_evaluate_sink_caps_extend(void)
1548          {
1549   1        
1550   1      }
1551          
1552          void _build_pps_status_message(void)
1553          {
1554   1        // message header: 
1555   1        pd_ext_txmsg_ptr->_msg_head.bits._message_type = EXTD_MSG_PPS_STATUS; 
1556   1        // extend header: 
1557   1        pd_ext_txmsg_ptr->_ext_head.bits._data_size0 = 0; 
1558   1        pd_ext_txmsg_ptr->_ext_head.bits._data_size1 = 4; 
1559   1        // data: 4 bytes
1560   1        pd_ext_txmsg_ptr->_data_bytes[0] = 0xFF;  // output voltage in 20mV...
1561   1        pd_ext_txmsg_ptr->_data_bytes[1] = 0xFF;
1562   1        pd_ext_txmsg_ptr->_data_bytes[2] = 0xFF;  // output current in 50mA...
1563   1        // bit-[2:1]: PTF - Persent Temperature Flag 
1564   1        // bit-[3]: OMF - Operation Mode Flag (1: CL(Current Limit), 0: CV(Contant Voltage)) 
1565   1        pd_ext_txmsg_ptr->_data_bytes[3] = 0x00;  
1566   1      }
1567          
1568          ///////////////////////////////////////// misc routines ///////////////////////////////////////////
1569          
1570          uint8 extract_apdo_voltage(uint8 max_100mv)
1571          {
1572   1        if(max_100mv >= 160) // 16V or 21V -> 15V or 20V 
1573   1          return (max_100mv - 1);
1574   1        else if(max_100mv > 90) // 11V -> 9V 
1575   1          return 90; 
1576   1        else  // 9V -> 5V 
1577   1          return 50;  
1578   1      }
1579          
1580          // state transition:
1581          void usbpd_state_transition(uint8 new_state)
1582          {
1583   1        new_port_state = new_state;
1584   1        usb_pd_add_event(0, USBPD_EVT_STATE_TRANSITION); 
1585   1      }
1586               
1587          ///////////////////////////////////////// general timers //////////////////////////////////////////
1588          
1589          // ms timer0: 
1590          void usbpd_ms_timer_start(uint8 index, uint16 count)
1591          {
1592   1        // confirm to stop:
1593   1        PE_TIMER_STOP(3,  (1 << (0 + index))); 
1594   1        // set count: 
1595   1        regmap0D(0x32+index*2) = (count >> 0) & 0xFF; 
1596   1        regmap0D(0x33+index*2) = (count >> 8) & 0xFF;
1597   1        // start:
1598   1        PE_TIMER_START(3, (1 << (0 + index))); 
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 27  

1599   1      }
1600          
1601          uint8 usbpd_ms_timer_is_timeout(uint8 index)
1602          {
1603   1        // check raw interrupt status:
1604   1        if(regmap0B(0x16) & (1 << (0 + index)))
1605   1        {
1606   2          // OK! timeout! - don't forget to clear interrupt:
1607   2          regmap0B(0x06) = (1 << (0 + index));
1608   2          // return:
1609   2          return 1; 
1610   2        }
1611   1        else
1612   1        {
1613   2          // not overflow yet...
1614   2          return 0; 
1615   2        }
1616   1      } 
1617          
1618          // us timer0: 
1619          void usbpd_us_timer_start(uint8 index, uint16 count)
1620          {
1621   1        // confirm to stop:
1622   1        PE_TIMER_STOP(3, (1 << (3 + index))); 
1623   1        // set count: 
1624   1        regmap0D(0x38+index*2) = (count >> 0) & 0xFF;
1625   1        regmap0D(0x39+index*2) = (count >> 8) & 0xFF; 
1626   1        // start:
1627   1        PE_TIMER_START(3, (1 << (3 + index)));  
1628   1      } 
1629          
1630          uint8 usbpd_us_timer_is_timeout(uint8 index)
1631          {
1632   1        // check raw interrupt status:
1633   1        if(regmap0B(0x16) & (1 << (3 + index)))
1634   1        {
1635   2          // OK! timeout! - don't forget to clear interrupt:
1636   2          regmap0B(0x06) = (1 << (3 + index));
1637   2          // return:
1638   2          return 1; 
1639   2        }
1640   1        else
1641   1        {
1642   2          // not overflow yet...
1643   2          return 0; 
1644   2        } 
1645   1      }
1646          
1647          // hardware delay...using timer2 as delay timer...
1648          void usbpd_hw_delay_ms(uint16 ms)
1649          {
1650   1        usbpd_ms_timer_start(2, ms); 
1651   1        while(!usbpd_ms_timer_is_timeout(2))
1652   1        {
1653   2        }   
1654   1      }
1655          
1656          void usbpd_hw_delay_us(uint16 us)
1657          {
1658   1        usbpd_us_timer_start(2, us);
1659   1        while(!usbpd_us_timer_is_timeout(2))
1660   1        {
C51 COMPILER V9.56.0.0   USBPD_POLICY                                                      07/10/2023 15:49:37 PAGE 28  

1661   2        }
1662   1      } 
1663          
1664          
1665          
1666          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3622    ----
   CONSTANT SIZE    =    192    ----
   XDATA SIZE       =     48    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5      30
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
